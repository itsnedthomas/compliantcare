/**
 * Apply geocode updates to Supabase in efficient batches
 * Uses the geocode_data.json file generated by batch_geocode.js
 * Run: node apply_geocodes.js
 */

const fs = require('fs');

const SUPABASE_URL = 'https://qdrbwvxqtgwjgitcambn.supabase.co';
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFkcmJ3dnhxdGd3amdpdGNhbWJuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk4OTE4NDMsImV4cCI6MjA4NTQ2Nzg0M30.8oJPT8Nyr4FbS2SZp9j9VEsnk5oAumV2_kWNam-RZD4';

const BATCH_SIZE = 200;  // Supabase REST can handle ~200 items per request for upsert
const DELAY_MS = 500;    // Be gentle with rate limits

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function updateBatch(updates) {
    // Use upsert-style PATCH by building individual calls
    // Since Supabase REST doesn't support bulk PATCH by ID easily,
    // we'll use a workaround with individual calls but with some parallelism

    const PARALLEL = 10;  // 10 parallel requests at a time

    for (let i = 0; i < updates.length; i += PARALLEL) {
        const chunk = updates.slice(i, i + PARALLEL);

        await Promise.all(chunk.map(async (update) => {
            const url = `${SUPABASE_URL}/rest/v1/facilities?%22Location%20ID%22=eq.${encodeURIComponent(update.locId)}`;

            try {
                const response = await fetch(url, {
                    method: 'PATCH',
                    headers: {
                        'apikey': SUPABASE_SERVICE_KEY,
                        'Authorization': `Bearer ${SUPABASE_SERVICE_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify({
                        latitude: update.lat,
                        longitude: update.lng
                    })
                });

                if (!response.ok && response.status !== 409) {
                    // Don't log 409 conflicts, just real errors
                    if (response.status !== 200 && response.status !== 204) {
                        console.error(`Failed ${update.locId}: ${response.status}`);
                    }
                }
            } catch (err) {
                console.error(`Error ${update.locId}: ${err.message}`);
            }
        }));

        // Small delay between parallel batches
        await delay(50);
    }
}

async function main() {
    console.log('=== Applying Geocode Updates ===\n');

    // Load the geocode data
    const data = JSON.parse(fs.readFileSync('geocode_data.json', 'utf8'));

    console.log(`Loaded ${Object.keys(data.postcodeCoords).length} postcodes`);
    console.log(`Mapping to ${Object.values(data.postcodeToLocationIds).flat().length} facilities`);

    // Build list of all updates
    const allUpdates = [];

    for (const [postcode, locationIds] of Object.entries(data.postcodeToLocationIds)) {
        const coords = data.postcodeCoords[postcode];
        if (coords) {
            for (const locId of locationIds) {
                allUpdates.push({
                    locId,
                    lat: coords.lat,
                    lng: coords.lng
                });
            }
        }
    }

    console.log(`Total updates to apply: ${allUpdates.length}\n`);

    // Process in batches
    let processed = 0;

    for (let i = 0; i < allUpdates.length; i += BATCH_SIZE) {
        const batch = allUpdates.slice(i, i + BATCH_SIZE);
        const batchNum = Math.floor(i / BATCH_SIZE) + 1;
        const totalBatches = Math.ceil(allUpdates.length / BATCH_SIZE);

        process.stdout.write(`\rProcessing batch ${batchNum}/${totalBatches} (${processed}/${allUpdates.length} done)...`);

        await updateBatch(batch);
        processed += batch.length;

        // Rate limit protection
        await delay(DELAY_MS);
    }

    console.log(`\n\n=== Update Complete ===`);
    console.log(`Processed ${processed} facility updates`);
}

main().catch(console.error);
